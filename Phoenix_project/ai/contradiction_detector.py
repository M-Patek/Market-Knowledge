# ai/contradiction_detector.py
"""
L2 Module: Detects contradictions between pieces of evidence.
"""
import logging
import asyncio
from datetime import datetime
import numpy as np
from typing import List, Dict, Any, Tuple
import json

# Placeholder imports
from ai.validation import EvidenceItem
from api.gemini_pool_manager import GeminiPoolManager
from ai.embedding_client import EmbeddingClient

class ContradictionDetector:
    """
    (L3 Patched) Detects semantic conflicts and uses an arbitrator agent to
    resolve them by generating new evidence.
    """
    def __init__(self,
                 pool_manager: GeminiPoolManager, # 添加池
                 embedding_client: EmbeddingClient,
                 similarity_threshold: float = 0.3): # (L3) Changed threshold
        """
        初始化检测器。

        Args:
            pool_manager: 用于 LLM 仲裁的统一API池。
            embedding_client: 用于为证据发现生成嵌入的客户端。
            similarity_threshold: (L3) 余弦相似度分数，低于此值则认为发现“可能冲突”。
        """
        self.logger = logging.getLogger("PhoenixProject.ContradictionDetector")
        self.embedding_client = embedding_client
        self.pool_manager = pool_manager # 存储池
        self.similarity_threshold = similarity_threshold
        self.model_name = "gemini-1.5-pro-latest" # 存储模型名称，按任务要求升级
        self.logger.info(f"ContradictionDetector configured with model '{self.model_name}' and GeminiPoolManager.")

    def _cosine_similarity(self, vec_a: np.ndarray, vec_b: np.ndarray) -> float:
        """计算两个向量之间的余弦相似度。"""
        return np.dot(vec_a, vec_b) / (np.linalg.norm(vec_a) * np.linalg.norm(vec_b))

    async def detect_and_resolve(self, evidence_list: List[EvidenceItem]) -> List[EvidenceItem]:
        """
        (L3) Detects contradictions and calls an arbitrator agent to generate new evidence to resolve them.

        Returns:
            A list of new EvidenceItem objects generated by the arbitrator.
        """
        if len(evidence_list) < 2:
            return []
        
        # 1. 异步获取所有嵌入
        # (This is a placeholder; in a real system, EvidenceItem might not have .finding)
        findings = [item.finding for item in evidence_list]
        try:
            vectors = await self.embedding_client.get_embeddings(findings, "contradiction_detection")
        except Exception as e:
            self.logger.error(f"Failed to get embeddings for contradiction detection: {e}")
            return []
            
        valid_evidence = [
            {"vector": vec, "_original_item": item}
            for vec, item in zip(vectors, evidence_list) if vec is not None
        ]

        if len(valid_evidence) < 2:
            return []

        conflict_pairs = []
        
        # 2. 执行向量化余弦相似度计算
        embeddings = np.array([doc['vector'] for doc in valid_evidence])
        # 将每个向量归一化为单位长度
        norm_embeddings = embeddings / np.linalg.norm(embeddings, axis=1, keepdims=True)
        # 计算余弦相似度矩阵
        similarity_matrix = np.dot(norm_embeddings, norm_embeddings.T)
        
        # 3. (L3) Find pairs with low semantic similarity as potential conflicts
        indices_row, indices_col = np.where(similarity_matrix < self.similarity_threshold)

        for i, j in zip(indices_row, indices_col):
            if i >= j: continue # 只考虑 i < j 的对，避免自比较和重复

            item_i = valid_evidence[i]['_original_item']
            item_j = valid_evidence[j]['_original_item']
            
            self.logger.info(f"Potential conflict identified (Similarity: {similarity_matrix[i, j]:.2f}). Sending to Arbitrator.")
            conflict_pairs.append((item_i, item_j))

        # 4. (L3) Call arbitrator for each conflicting pair to generate new evidence
        if not conflict_pairs:
            return []
        
        tasks = [self._generate_arbitration_evidence(item_i, item_j) for item_i, item_j in conflict_pairs]
        arbitration_results = await asyncio.gather(*tasks)
        
        # Filter out any failed arbitrations (which return None)
        new_evidence = [item for item in arbitration_results if item is not None]
        if new_evidence:
            self.logger.warning(f"Arbitrator generated {len(new_evidence)} new evidence items to resolve conflicts.")
            
        return new_evidence

    async def _generate_arbitration_evidence(self, item1: EvidenceItem, item2: EvidenceItem) -> EvidenceItem | None:
        """(L3) Calls an LLM to analyze a conflict and generate a new, synthesized EvidenceItem."""
        prompt = f"""
        You are an expert arbitrator. Analyze the following two conflicting pieces of evidence regarding a financial asset. 
        Synthesize them and generate a new, more nuanced piece of evidence. 
        Your response MUST be a JSON object with three keys: "finding" (your new summary), "score" (a float from -1.0 to 1.0), and "provenance_confidence" (a float from 0.0 to 1.0).

        Evidence A: "{item1.finding}" (Original Score: {item1.score})
        Evidence B: "{item2.finding}" (Original Score: {item2.score})
        """
        try:
            contents = [{"parts": [{"text": prompt}]}]
            
            # Use the pool manager to make the call
            response = await self.pool_manager.query_model_async(
                model_name=self.model_name,
                contents=contents,
                generation_config={"temperature": 0.5}
            )
            
            # (L3) TODO: Add robust JSON parsing and validation here
            result_json = json.loads(response.text)
            
            return EvidenceItem(
                source="arbitrator_agent",
                finding=result_json["finding"],
                score=result_json["score"],
                provenance_confidence=result_json["provenance_confidence"],
                timestamp=datetime.now()
            )
        except Exception as e:
            self.logger.error(f"LLM arbitration call to generate evidence failed: {e}")
            return None
