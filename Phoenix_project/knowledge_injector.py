"""
Phoenix Project - Knowledge Injection Service (Task 4.3)

This module is responsible for taking the heuristic rules generated by the
L3 MetaCognitiveAgent and injecting them back into the L1 system, either
by adjusting agent prompts or by updating source credibility.
"""

import os
import json
import logging
from typing import List, Dict, Any

# Import the store we built in Phase 2 (Task 2.2)
try:
    from ai.bayesian_fusion_engine import SourceCredibilityStore
except ImportError:
    logging.error("Could not import SourceCredibilityStore. Credibility adjustments will fail.")
    # Define a mock class to allow the module to be imported
    class SourceCredibilityStore:
        def __init__(self, *args, **kwargs):
            logging.warning("Using MOCK SourceCredibilityStore.")
        def update_source_credibility(self, *args, **kwargs):
            logging.error("MOCK store: update_source_credibility called but not implemented.")


logger = logging.getLogger("PhoenixProject.KnowledgeInjector")

PROMPTS_DIR = "Phoenix_project/prompts"

def inject_rules(rules: List[Dict[str, Any]]):
    """
    Task 4.3: Main function to parse and inject L3 rules.
    """
    logger.info(f"Injecting {len(rules)} new heuristic rules...")
    
    # Initialize the store to handle credibility adjustments
    credibility_store = SourceCredibilityStore()
    
    for rule in rules:
        try:
            action = rule.get('action', {})
            action_type = action.get('type')
            target_agent = action.get('target_agent')

            if action_type == "adjust_credibility" and target_agent:
                # --- Injection Path 2 (Adjust Credibility) ---
                # Apply a "punitive adjustment" as a failure event
                logger.info(f"Applying punitive credibility adjustment to: {target_agent}")
                credibility_store.update_source_credibility(target_agent, was_correct=False)

            elif action_type == "update_prompt" and target_agent:
                # --- Injection Path 1 (Update Prompt) ---
                rule_text = rule.get('description', 'No description provided.')
                config_path = os.path.join(PROMPTS_DIR, f"{target_agent}.json")
                
                if os.path.exists(config_path):
                    with open(config_path, 'r+') as f:
                        config = json.load(f)
                        if 'permanent_constraints' not in config:
                            config['permanent_constraints'] = []
                        
                        if rule_text not in config['permanent_constraints']:
                             config['permanent_constraints'].append(rule_text)
                             f.seek(0)
                             json.dump(config, f, indent=2)
                             f.truncate()
                             logger.info(f"Injected new constraint into: {target_agent}.json")
                        else:
                             logger.info(f"Constraint already exists in {target_agent}.json. Skipping.")
                else:
                    logger.warning(f"Could not find prompt file for injection: {config_path}")

        except Exception as e:
            logger.error(f"Failed to inject rule {rule.get('name')}: {e}")
