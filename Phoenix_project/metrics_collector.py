from typing import Dict, Any, Optional
import time

from monitor.logging import ESLogger
from monitor.metrics import PrometheusMetrics
from core.pipeline_state import PipelineState


class MetricsCollector:
    """
    Observes the PipelineState and records performance metrics, system health,
    and other key performance indicators (KPIs) to a monitoring backend
    (e.g., Prometheus).
    """

    def __init__(
        self,
        config: Dict[str, Any],
        logger: ESLogger,
        metrics_backend: PrometheusMetrics,
    ):
        """
        Initializes the MetricsCollector.

        Args:
            config: Configuration dictionary for metrics.
            logger: An instance of ESLogger for logging.
            metrics_backend: The client for the metrics system (e.g., Prometheus).
        """
        self.config = config
        self.logger = logger
        self.metrics = metrics_backend
        self.logger.log_info("MetricsCollector initialized.")

        # Register common metrics
        self.metrics.register_counter(
            "pipeline_events_processed_total",
            "Total number of events processed by the pipeline",
            ["source", "status"],
        )
        self.metrics.register_gauge(
            "pipeline_processing_time_seconds",
            "Time taken to process the last event",
            ["component"],
        )
        self.metrics.register_gauge(
            "pipeline_last_event_timestamp_seconds",
            "Timestamp of the last event processed",
        )
        self.metrics.register_gauge(
            "fusion_uncertainty_score",
            "Uncertainty score of the last fusion result",
            ["event_source"],
        )
        self.metrics.register_gauge(
            "fusion_confidence_score",
            "Calibrated confidence of the last fusion result",
            ["event_source"],
        )
        self.metrics.register_counter(
            "cognitive_signals_generated_total",
            "Total number of signals generated by the cognitive engine",
            ["strategy", "decision"],
        )
        self.metrics.register_counter(
            "execution_orders_placed_total",
            "Total number of orders placed by the execution manager",
            ["symbol", "side"],
        )
        self.metrics.register_counter(
            "knowledge_graph_injections_total",
            "Total number of successful KG injections",
            ["status"],
        )

    async def observe_state(self, state: PipelineState):
        """
        Observes the final state of the pipeline after a run and records metrics.

        Args:
            state: The PipelineState object after processing.
        """
        self.logger.log_debug(f"Observing state for event: {state.event_id}")

        try:
            status = "error" if state.error else "success"
            source = state.raw_event.get("source", "unknown") if state.raw_event else "unknown"
            
            # --- Pipeline Metrics ---
            self.metrics.inc_counter(
                "pipeline_events_processed_total",
                labels={"source": source, "status": status},
            )
            
            if state.start_time:
                end_time = time.time()
                total_duration = end_time - state.start_time
                self.metrics.set_gauge(
                    "pipeline_processing_time_seconds",
                    total_duration,
                    labels={"component": "total_pipeline"},
                )
            
            self.metrics.set_gauge_to_current_time("pipeline_last_event_timestamp_seconds")

            # --- Fusion Metrics ---
            if state.fusion_result:
                event_source = state.fusion_result.source or "unknown"
                if state.fusion_result.uncertainty_score is not None:
                    self.metrics.set_gauge(
                        "fusion_uncertainty_score",
                        state.fusion_result.uncertainty_score,
                        labels={"event_source": event_source},
                    )
                if state.fusion_result.calibrated_confidence is not None:
                    self.metrics.set_gauge(
                        "fusion_confidence_score",
                        state.fusion_result.calibrated_confidence,
                        labels={"event_source": event_source},
                    )

            # --- Cognitive Metrics ---
            if state.cognitive_signal:
                signal = state.cognitive_signal
                self.metrics.inc_counter(
                    "cognitive_signals_generated_total",
                    labels={
                        "strategy": signal.get("strategy_id", "unknown"),
                        "decision": signal.get("decision", "unknown"),
                    },
                )

            # --- Execution Metrics ---
            if state.execution_order:
                order = state.execution_order
                self.metrics.inc_counter(
                    "execution_orders_placed_total",
                    labels={
                        "symbol": order.get("symbol", "unknown"),
                        "side": order.get("side", "unknown"),
                    },
                )

            # --- Knowledge Graph Metrics ---
            if state.knowledge_injected is not None:
                kg_status = "success" if state.knowledge_injected else "failure"
                self.metrics.inc_counter(
                    "knowledge_graph_injections_total",
                    labels={"status": kg_status},
                )

            self.logger.log_debug(f"Successfully recorded metrics for event: {state.event_id}")

        except Exception as e:
            self.logger.log_error(
                f"Failed to record metrics for event {state.event_id}: {e}",
                exc_info=True,
            )
