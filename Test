import os
import requests
import json
import random
import backtrader as bt
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
from datetime import datetime

# --- Section 1: Data Sensor Modules (Ongoing Upgrades) ---
# ENGINEERING NOTE: Per "Phoenix Project", we will replace these prototypes one by one.

def get_real_market_news() -> list:
    """
    PROTOTYPE: Simulates fetching real-time market news.
    PHOENIX GOAL: Replace with a production-grade NewsAPI client.
    """
    print("\n--- [Sensor Call: Market News (Prototype)] ---")
    headlines = random.choice([
        ["Tech stocks surge on unexpected dovish Fed pivot."],
        ["Inflation fears resurface, sending jitters across the market."],
        ["Sector-wide software upgrades lead to broad positive sentiment."]
    ])
    print("Simulated news headlines obtained.")
    return headlines

def get_vix_index() -> float:
    """
    PROTOTYPE: Simulates fetching the VIX index.
    PHOENIX GOAL: Replace with a real-time data provider for market indices.
    """
    print("--- [Sensor Call: VIX Index (Prototype)] ---")
    vix = random.uniform(12.0, 35.0)
    print(f"Simulated VIX: {vix:.2f}")
    return vix

def get_market_breadth() -> float:
    """
    PROTOTYPE: Simulates fetching market breadth data.
    PHOENIX GOAL: Replace with an API call for advance/decline data.
    """
    print("--- [Sensor Call: Market Breadth (Prototype)] ---")
    breadth = random.uniform(0.25, 0.85)
    print(f"Simulated Market Breadth: {breadth:.2%}")
    return breadth

def get_cross_market_data() -> dict:
    """
    PROTOTYPE: Simulates fetching cross-market data (e.g., Treasury yields).
    PHOENIX GOAL: Replace with a reliable source for economic data (e.g., FRED via API).
    """
    print("--- [Sensor Call: Cross-Market Data (Prototype)] ---")
    yield_rate = random.uniform(2.5, 5.0)
    print(f"Simulated 10Y Treasury Yield: {yield_rate:.2f}%")
    return {"us_10y_yield": yield_rate}

def get_volatility_regime(current_vix: float) -> str:
    """
    PROTOTYPE: Simulates determining the volatility regime.
    PHOENIX GOAL: Implement a robust calculation based on historical VIX data.
    """
    print("--- [Sensor Call: Volatility Regime (Prototype)] ---")
    # ... (Simulation logic remains the same) ...
    regime = random.choice(["Fear Rising", "Fear Fading", "Low Volatility"])
    print(f"Simulated Volatility Regime: {regime}")
    return regime

# --- Section 2: Gemini Cognitive Engine (Marshal-Level Brain - Prototype) ---
# ENGINEERING NOTE: This function simulates the final decision logic.
# In "Phoenix Project", this will be a robust module with real, async API calls.

def marshal_capital_allocation(candidate_tickers: List[str]) -> List[Dict]:
    """
    PROTOTYPE: Simulates the entire marshal-level decision process.
    """
    print("\n--- [Cognitive Engine Call: Marshal Allocation (Prototype)] ---")
    # ... (The detailed simulation logic from the previous version is kept here) ...
    print(f"Received candidate assets: {candidate_tickers}")
    analysis_results = [{"ticker": t, "opportunity_score": random.uniform(40, 98)} for t in candidate_tickers]
    worthy_targets = [res for res in analysis_results if res["opportunity_score"] > 55]
    if not worthy_targets:
        print("Marshal's Decision: No high-quality opportunities found. Stand down.")
        return []
    # ... (Rest of the simulation logic is omitted for brevity but is identical to the V0.9 prototype) ...
    battle_plan = [{"ticker": t['ticker'], "capital_allocation_pct": round(t['opportunity_score']/200, 2)} for t in worthy_targets]
    print("\n--- [Marshal's Final Battle Plan] ---")
    for deployment in battle_plan: print(f"- Asset: {deployment['ticker']}, Deploy Capital: {deployment['capital_allocation_pct']:.2%}")
    return battle_plan

# --- Section 3: Strategy Execution Layer (The Roman Legion) ---
# ENGINEERING NOTE: This strategy is an "execution-only" agent.
# Its logic will be expanded in "Phoenix Project" to handle real-world complexities.

class RomanLegionStrategy(bt.Strategy):
    params = (('battle_plan', None),)

    def __init__(self):
        if not self.params.battle_plan:
            raise ValueError("Battle plan not received! The Legion cannot be deployed!")
        self.data_map = {d._name: d for d in self.datas}

    def start(self):
        print(f"\n{self.datas[0].datetime.date(0).isoformat()}: [Legion Commander]: Battle plan received! Deploying forces...")
        total_value = self.broker.getvalue()
        for deployment in self.params.battle_plan:
            ticker = deployment['ticker']
            allocation_pct = deployment['capital_allocation_pct']
            if ticker in self.data_map:
                target_value = total_value * allocation_pct
                price = self.data_map[ticker].close[0]
                size_to_buy = int(target_value / price)
                if size_to_buy > 0:
                    print(f"  - Issuing BUY order for {ticker}: {size_to_buy} shares.")
                    self.buy(data=self.data_map[ticker], size=size_to_buy)

    def notify_order(self, order):
        if order.status == order.Completed and order.isbuy():
            print(f"{self.datas[0].datetime.date(0).isoformat()}: [Comms]: Marshal, the {order.data._name} legion is in position!")

# --- Section 4: Main Execution Engine (The High Command) ---

ASSET_UNIVERSE = ['QQQ', 'SPY', 'GLD', 'TLT', 'IWM'] 

# ***** V1.0 UPGRADE: PRODUCTION-GRADE PRICE SENSOR *****
def get_real_price_data(ticker: str, start_date: str, end_date: str, timeframe: str = '1Day') -> Optional[pd.DataFrame]:
    """
    PRODUCTION-GRADE V1.0: Fetches real historical price data via Alpaca API.
    Includes full error handling and returns a Backtrader-compatible DataFrame.
    """
    print(f"\n--- [Sensor Call: Price Data (Production V1.0)] ---")
    
    api_key = os.getenv("APCA_API_KEY_ID")
    secret_key = os.getenv("APCA_API_SECRET_KEY")
    
    if not api_key or not secret_key:
        print(f"CRITICAL ERROR: Alpaca API keys not found for {ticker}. Cannot fetch real price data.")
        return None

    base_url = "https://data.alpaca.markets/v2/stocks/bars"
    params = {
        'symbols': ticker, 'timeframe': timeframe, 'start': f"{start_date}T00:00:00Z",
        'end': f"{end_date}T23:59:59Z", 'limit': 10000, 'adjustment': 'raw'
    }
    headers = {'APCA-API-KEY-ID': api_key, 'APCA-API-SECRET-KEY': secret_key}

    try:
        print(f"Requesting production data for {ticker} from Alpaca...")
        response = requests.get(base_url, headers=headers, params=params, timeout=30)
        response.raise_for_status()
        data = response.json()

        if ticker in data and data[ticker]:
            df = pd.DataFrame(data[ticker])
            df.rename(columns={'t': 'Date', 'o': 'Open', 'h': 'High', 'l': 'Low', 'c': 'Close', 'v': 'Volume'}, inplace=True)
            df['Date'] = pd.to_datetime(df['Date'])
            df.set_index('Date', inplace=True)
            print(f"Successfully obtained and formatted {len(df)} real data points for {ticker}.")
            return df[['Open', 'High', 'Low', 'Close', 'Volume']]
        else:
            print(f"WARNING: No data returned for {ticker} from Alpaca API.")
            return None
    except Exception as e:
        print(f"CRITICAL ERROR: Failed to fetch price data for {ticker}: {e}")
        return None

if __name__ == '__main__':
    # Step 1: Reconnaissance Scan (Using Prototype for now)
    top_assets = random.sample(ASSET_UNIVERSE, 3) # Simplified scanner
    print(f"--- [Reconnaissance Scan] Top candidates: {top_assets} ---")
    
    if not top_assets:
        print("\n[High Command]: Reconnaissance found no viable opportunities. Stand down for today.")
    else:
        # Step 2: Marshal's Strategic Decision (Using Prototype for now)
        battle_plan = marshal_capital_allocation(top_assets)
        
        if not battle_plan:
            print("\n[High Command]: Marshal advises against any deployment today.")
        else:
            # Step 3: Prepare the Battlefield (Cerebro)
            cerebro = bt.Cerebro()
            
            # Step 4: Supply the Legions (Data Feeds)
            assets_in_plan = [p['ticker'] for p in battle_plan]
            for ticker in assets_in_plan:
                # ***** CALLING THE PRODUCTION-GRADE SENSOR *****
                dataframe = get_real_price_data(ticker, '2022-01-01', '2024-12-31')
                if dataframe is not None:
                    cerebro.adddata(bt.feeds.PandasData(dataname=dataframe, name=ticker))

            if not cerebro.datas:
                print("\nCRITICAL ERROR: Failed to load data for any asset in the battle plan. Aborting operation.")
            else:
                # Step 5: Deploy the Legion with the Battle Plan
                cerebro.addstrategy(RomanLegionStrategy, battle_plan=battle_plan)
                cerebro.broker.setcash(1_000_000.0)
                cerebro.broker.setcommission(commission=0.001)

                # Step 6: Authorize the Operation
                print('\n--- Launching "Phoenix Project" V1.0 (Price Grounded) ---')
                results = cerebro.run()
                
                # Step 7: After-Action Report
                print('--- Operation Concluded ---')
                print(f'Final Empire Assets: {cerebro.broker.getvalue():.2f}')
